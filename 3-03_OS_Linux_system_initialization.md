# Домашнее задание к занятию "3.3 Инициализация системы, Init, systemd"

---

### Задание 1.

Выполните systemd-analyze blame.

*Укажите, какие модули загружаются дольше всего.*

***Ответ:***

В моей системе дольше всего загружаются: postfix.service, tuned.service, NetworkManager-wait-online.service, udisks2.service

<a href="https://ibb.co/jZj7KN0"><img src="https://i.ibb.co/fGTmRg6/1-1.png" alt="1-1" border="0"></a>

---

### Задание 2.

Какой командой вы посмотрите ошибки ядра, произошедшие начиная со вчерашнего дня?

*Напишите ответ в свободной форме.*

***Ответ:***

Ошибки ядра, произошедшие начиная со вчерашнего дня можно посмотреть командой: `journalctl --since=yesterday --until=now` или `journalctl -S yesterday -U now`

Также можно посмотреть ошибки запуска служб, прибавив название интересующей нас службы: `journalctl --since=yesterday --until=now sshd`
---

### Задание 3. 

Запустите команду loginctl user-status.

*Что выполняет, для чего предназначена эта утилита?*

***Ответ:***

Утилита `loginctl` позволяет получать информацию о том, какие пользователи находятся в системе в данный момент, как давно они вошли, какой uid им принадлежит, сколько сеансов запущено на данный момент и т.д. Кроме этого, loginctl позволяет всем этим управлять.
В частности команда `loginctl user-status` без дополнительных параметров выдает информацию о процессах и службах, запущенных под текущим пользователем. Дополнительными параметрами в данном случае могут выступать имена и uid пользователей.

---

### Задание 4.

Есть ли у вас на машине службы, которые не смогли запуститься? Как вы это определили?

*Приведите ответ в свободной форме.*

***Ответ:***

На моей ВМ все службы запускаются без сбоев. Определить это можно командой `journalctl -p` с указанием приоритета от 0 до 7. Возможные значения приоритета:
0, emerg – система не работоспособна
1, alert – система требует немедленного вмешательства
2, crit – состояние системы критическое
3, err – сообщение об ошибке
4, warning – предупреждение о возможной проблеме
5, notice – нормальное, но важное событие
6, info – информационное сообщение
7, debug – отладочное сообщение

В частности, для того чтобы вывести информацию о службах, которые не смогли запуститься нужно использовать команду: `journalctl -p err`. Можно также посмотреть, какие ошибки выпадали в предыдущих загрузках по команде `journalctl -b -1 -p err`, где параметры -b -1 указывают на нужную загрузку. Вместо -1 можно использовать UID загрузки, посмотрев его командой `journalctl --list-boots`

---

**

## Дополнительные задания (со звездочкой*)
Эти задания дополнительные (не обязательные к выполнению) и никак не повлияют на получение вами зачета по этому домашнему заданию. Вы можете их выполнить, если хотите глубже и/или шире разобраться в материале.

### Задание 5.

Можно ли с помощью systemd отмонтировать раздел/устройство?

*Приведите ответ в свободной форме.*

***Ответ:***

Среди множества функций, которые предоставляет systemd, есть функция автомонтирования. При настройке автомонтирования указанный каталог будет подмонтирован только после первого обращения к нему (точнее, прямо во время). Как это работает? SystemD Automount надстраивается над SystemD Mount - встроенного механизма монтирования файловых систем, и позволяет производить монтирование только в тот момент времени, когда необходимо фактически обратиться к точке монтирования, например чтобы скопировать какой-нибудь файл. При чем не важно, что это за файловая система и где она находится: жестий диск, флэшка, NFS, сетевой ресурс MS Windows и т.д. Такой способ монтирования может сэкономить немало времени при загрузке компьютера, особенно если монтировать сетевую файловую систему. Так как ей для работы нужен уже настроенный сетевой интерфейс. Каждая такая файловая система должна быть описана специальным unit-файлом, чтобы SystemD знал когда, что и куда нужно смонтировать. Именоваться такой файл должен исходя из точки монтирования (то, куда относительно корневого каталога должна быть смонтирована файловая система), иметь суффикс ".mount" и располагаться в каталоге /lib/systemd/system. А automount unit-файл должен делать всё то же самое, только иметь суффикс не ".mount", а ".automount". Соответственно активным из этих двух файлов должен быть automount unit-файл, а второй просто ждать, когда его вызовет automount.

---